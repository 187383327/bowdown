<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Best game EVER</title>
		<style>
			body { margin: 0; height: 100vh}
			canvas { display: block }
            #info {
                position: absolute;
                bottom: 10px;
                width: 100%;
                text-align: right;
                z-index: 100;
                display: block;
                font-size: 20pt;
                color: orange;
            }
		</style>
	</head>
	<body>
        <div id="info">
            <p id="info0"></p>
            <p id="info1"></p>
            <p id="info2"></p>
            <p id="info3"></p>
        </div>
		<script src="js/three.js"></script>
		<script>
			var scene = initScene();
            var camera = initCamera();
            var renderer = initRenderer();            
            document.body.appendChild( renderer.domElement );

            var cameraTarget = new THREE.Vector3( 0, 1, 0 );
            var theta = 0
            var phi = 0
            var forward = false
            var backward = false
            var left = false
            var right = false

            var cube = getCube();
            scene.add( cube );
            
            scene.add( getHemisphereLight() );
            scene.add( getDirectionalLight() );
            scene.add( getGround() );

            var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
            document.addEventListener( 'mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onClick);
            window.addEventListener('resize', resize);

            const ws = new WebSocket('ws://localhost:18181');

            ws.onopen = function open() {
                ws.send('something');
            };

            function initScene() {
                var scene = new THREE.Scene();
                return scene;
            }

            function initCamera() {
                var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.z = 5;
                return camera;
            }

            function initRenderer() {
                var renderer = new THREE.WebGLRenderer();
                renderer.setClearColor("#e5e5e5");
                renderer.setSize( window.innerWidth, window.innerHeight );
                return renderer;
            }
            
            function animate() {
                requestAnimationFrame( animate );
                if (forward || backward || left || right) {
                    movePlayer();
                    updateCamera();
                }
                render();
            }
            
            function render() {
                renderer.render( scene, camera );
            }

            function movePlayer() {
                var movementSpeed = 0.3;
                var direction = new THREE.Vector3();
                camera.getWorldDirection(direction)
               
                // make direction 2d (x,z) and normalize
                // then multiply by movement speed
                var b = 1/(abs(direction.x)+abs(direction.z));
                var directionX = b*direction.x;
                var directionZ = b*direction.z;

                var x, z;
                if (forward) {
                    cube.position.z += directionZ;
                    cameraTarget.z += directionZ;
                    cube.position.x += directionX;
                    cameraTarget.x += directionX;
                }
                if (backward) {
                    cube.position.z -= directionZ;
                    cameraTarget.z -= directionZ;
                    cube.position.x -= directionX;
                    cameraTarget.x -= directionX;
                }
                if (left) {
                    cube.position.z -= directionX;
                    cameraTarget.z -= directionX;
                    cube.position.x += directionZ;
                    cameraTarget.x += directionZ;
                }
                if (right) {
                    cube.position.z += directionX;
                    cameraTarget.z += directionX;
                    cube.position.x -= directionZ;
                    cameraTarget.x -= directionZ;
                }
            }

            function toggleKey(event, toggle) {
                switch(event.key) {
                    case 'w':
                        forward = toggle;
                        break;
                    case 'a':
                        left = toggle;
                        break;
                    case 's':
                        backward = toggle;
                        break;
                    case 'd':
                        right = toggle;
                        break;
                }
            }

            function onKeyDown(event) {
                toggleKey(event, true);
            }

            function onKeyUp(event) {
                toggleKey(event, false);
            }

            function onClick(event) {
                document.body.requestPointerLock();
            }
            
            function updateCamera() {
                var distance = 5;
                camera.position.x = cameraTarget.x + distance * Math.sin(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);
                camera.position.y = cameraTarget.y + distance * Math.sin(phi * Math.PI / 360);
                camera.position.z = cameraTarget.z + distance * Math.cos(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);
                camera.lookAt(cameraTarget);
                camera.updateMatrix();
            }
            
            function onMouseMove( event ) {
                var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                theta -= movementX * 0.2
                phi -= movementY * 0.2
                updateCamera();
            }

            function resize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }

            function getCube() {
                var geometry = new THREE.BoxGeometry( 1, 1, 1 );
                var material = new THREE.MeshLambertMaterial( { color: 0x00ff00 } );
                var cube = new THREE.Mesh( geometry, material );
                cube.castShadow = true;
                cube.receiveShadow = true;
                return cube;
            }

            function getGround() {
                var geometry = new THREE.PlaneGeometry(10, 20, 0);
                var texture = new THREE.TextureLoader().load('textures/grass.png')
                var material = new THREE.MeshBasicMaterial({map: texture, side: THREE.DoubleSide});
                var plane = new THREE.Mesh( geometry, material );
                plane.rotateX(Math.PI/2);
                plane.translateZ(2);
                plane.receiveShadow = true;
                return plane;
            }

            function getHemisphereLight() {
                var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
                hemiLight.color.setHSL( 0.6, 1, 0.6 );
                hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
                hemiLight.position.set( 0, 50, 0 );
                hemiLight.visible = true;
                return hemiLight;
            }
            
            function getDirectionalLight() {
                var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
                dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( - 1, 1.75, 1 );
                dirLight.position.multiplyScalar( 30 );
                dirLight.castShadow = true;
                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;
                var d = 50;
                dirLight.shadow.camera.left = - d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = - d;
                dirLight.shadow.camera.far = 3500;
                dirLight.shadow.bias = - 0.0001;
                dirLight.visible = true;
                return dirLight;
            }

            function abs(num) {
                return Math.abs(num);
            }
            
            animate();
            
		</script>
	</body>
</html>