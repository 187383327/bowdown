[1mdiff --git a/client/src/camera.js b/client/src/camera.js[m
[1mindex 447aa76..f7521ad 100644[m
[1m--- a/client/src/camera.js[m
[1m+++ b/client/src/camera.js[m
[36m@@ -27,6 +27,7 @@[m [mcamera.nextPosition = function(dist) {[m
         nextPos.x = dist * Math.sin(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);[m
         nextPos.y = dist * Math.sin(phi * Math.PI / 360);[m
         nextPos.z = dist * Math.cos(theta * Math.PI / 360) * Math.cos(phi * Math.PI / 360);[m
[32m+[m[32m        return cameraTarget.clone().add(nextPos.clone())[m
         return cameraTarget.clone().add(nextPos.clone().applyEuler(player1.getRotation()))[m
     }[m
 }[m
[1mdiff --git a/client/src/player1.js b/client/src/player1.js[m
[1mindex 9f83bce..f285f6c 100644[m
[1m--- a/client/src/player1.js[m
[1m+++ b/client/src/player1.js[m
[36m@@ -112,7 +112,7 @@[m [mloader.load(models('./benji_'+player1.race+'.gltf'), ( gltf ) => {[m
 [m
     player1.doubleJumped = false[m
     player1.animate = function(delta, input){[m
[31m-        this.gltf.scene.up = this.getPosition().clone().normalize()        [m
[32m+[m[32m//         this.gltf.scene.up = this.getPosition().clone().normalize()[m[41m        [m
         var nextPos, rotation;[m
         var falling = player1.falling(delta)[m
         var inputDirection = getDirection(input, delta)[m
[36m@@ -120,10 +120,12 @@[m [mloader.load(models('./benji_'+player1.race+'.gltf'), ( gltf ) => {[m
         camera.getWorldDirection(cameraDirection)[m
         var localCameraDirection = cameraDirection.clone().applyQuaternion(this.gltf.scene.quaternion.clone().conjugate())[m
         localCameraDirection.setY(0).normalize()[m
[31m-        var direction = localCameraDirection.clone().applyAxisAngle(new Vector3(0,1,0), -Math.atan2(inputDirection.x, inputDirection.y)).applyEuler(this.getRotation()).multiplyScalar(delta*player1.runOrSprint(input))[m
[31m-        var quat = new Quaternion().setFromUnitVectors(new Vector3(0,1,0), this.gltf.scene.up)[m
[32m+[m[32m//         var direction = localCameraDirection.clone().applyEuler(this.getRotation()).multiplyScalar(delta*player1.runOrSprint(input))[m
[32m+[m[32m        var direction = localCameraDirection.clone().applyAxisAngle(new Vector3(0,1,0), Math.atan2(inputDirection.x, inputDirection.y)).applyEuler(this.getRotation()).multiplyScalar(delta*player1.runOrSprint(input))[m
[32m+[m[32m        var quat = new Quaternion().setFromUnitVectors(new Vector3(0,1,0), this.getPosition().clone().normalize())[m
[32m+[m[32m        quat.multiply(new Quaternion().setFromUnitVectors(new Vector3(1,0,0), new Vector3(inputDirection.x, 0, inputDirection.y)))[m
         if (inputDirection.length()) {[m
[31m-            quat.multiply(new Quaternion().setFromAxisAngle(new Vector3(0,1,0), Math.atan2(inputDirection.x, inputDirection.y)))[m
[32m+[m[32m//             quat.multiply(new Quaternion().setFromAxisAngle(new Vector3(0,1,0), Math.atan2(inputDirection.x, inputDirection.y)))[m
 //             quat.multiply(new Quaternion().setFromUnitVectors(new Vector3(1,0,0)), direction.clone().normalize())[m
         }[m
         this.gltf.scene.setRotationFromQuaternion(quat)[m
